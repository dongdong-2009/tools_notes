 BCM2835 芯片数据手册（中文翻译）

1 前言
1.1 概述

BCM2835 具有以下可以被 ARM 安全使用的外设：

    定时器
    中断控制器
    GPIO
    USB
    PCM/I2S
    DMA
    I2C 主机
    I2C/SPI 从机
    SPI0,SPI1,SPI2
    PWM
    UART0,UART1

本数据手册旨在对这些外设的细节进行描述，以方便开发者对该芯片移植操作系统。

有一些被 GPU 控制的外设将不会出现在本数据手册。不推荐从 ARM 访问这些外设。

/////////////////////////////////////////
1.2 地址映射
/////////////////////////////////////////

//////////////
1.2.1 图表概述(see my git hub )
//////////////
除了 ARM 的内存管理单元（ MMU ）之外，BCM2835 还增加了一个粗颗粒的 MMU，用于将 ARM 的物理地址映射到系统总线地址。
下面这幅图片展示了与之相关的地址空间。


在 ARM Linux 中的地址如下：

    首先是 ARM 内核规定的虚拟地址
    之后是 ARM MMU 映射的物理地址
    之后是 ARM mapping MMU 映射的总线地址
    最后为适当的外设和 RAM 地址


//////////////
1.2.2 ARM 虚拟地址 （标准 Linux 内核）
//////////////
一般情况下，BCM2835 标准的 Linux 内核在存储单元的头部对整个可使用的 RAM 进行了连续的地址映射。该内核被配置为在内核和用户使用的存储空间中分割了 1GB/3GB 的空间。

在 ARM 和 GPU 之间分割的区域用于存放一个支持的 start*.elf 文件，该文件被用作 SD 卡 FAT32 boot 区域的 start.elf。分配给 GPU 的最小存储量为 32MB，但是这将影响其多媒体性能；例如，32MB 的空间小于让 GPU 进行 1080p30 解码所需的缓存空间。

在内核模式下，虚拟地址为 0xC0000000 到 0xEFFFFFFF。

在用户模式下，即在运行 ARM Linux 时，虚拟内存为0x00000000 到 0xBFFFFFFF。

外设（物理地址为0x20000000）被映射到从地址 0xF20000000 处开始的内核虚拟地址空间。因此，在总线地址 0x7Ennnnnn 处的外设在 ARM 内核的虚拟地址为 0xF2nnnnnn。


//////////////
1.2.3 ARM 物理地址
//////////////
RAM 的物理地址从 0x00000000 处开始。

    ARM 定义的 RAM 地址从 0x00000000 开始
    只有在系统被配置为支持内存映射显示时，RAM 中的 VideoCore 部分才会被映射（这是常见情况）

VideoCore MMU 通过 VideoCore （和 VideoCore 外设）将 ARM 物理地址空间映射到总线地址空间。RAM 的总线地址被设置为映射到 VideoCore 内 uncache[^1] 总线地址 0xC0000000 处开始。

外设的物理地址是从 0x20000000 到0x20FFFFFF。外设的总线地址被映射到外设地址总线 0x7E000000 处开始。因此访问地址 0x7Ennnnnn 实际上是在访问物理地址 0x20nnnnnn。


/////////////////
1.2.4 总线地址
/////////////////
在本文中将外设地址称为总线地址。软件直接访问外设时，需要用如上所示的方式将地址转换位物理地址或虚拟地址。软件使用 DMA 访问外设时必须使用总线地址。

软件直接访问 RAM 时，必须使用物理地址（从0x00000000开始）。软件使用 DMA 访问 RAM 时，必须使用总线地址（从0xC0000000开始）。



/////////////////////////////////////////
1.3 外设访问内存的正确顺序
/////////////////////////////////////////
BCM2835 系统使用 AMBA AXI 兼容的接口结构。为了保证较低的系统复杂性和较高的数据吞吐量，BCM2835 的 AXI 系统并没有始终按照次序地返回数据[^2]。GPU 具有特殊的逻辑可以不按次序的拷贝数据，但是 ARM 内核并不支持这个逻辑。因此在使用 ARM 访问外设时必须予以警惕。

在访问同一个外设时，数据总是按照次序地返回。但当访问是从一个外设到另一个外设时，数据就可能会错乱。为了确保数据具有正确的顺序，最简单的方法是在代码的临界区域设置内存隔离指令（memory barrier instructions）。如下两点：

    在首次写外设前设置一个内存写屏障
    在最后一次读外设之后设置一个内存读屏障

并不是每一次读或写操作之后都需要设置一个内存隔离指令，仅在代码对一个外设读或写操作是跟在对另一不同外设执行读或写操作之后时才需要，这通常是在进入或者退出外设服务函数时。

在代码的任何位置都有可能产生中断，因此你需要有如下防护措施。如果在读一个外设时发生中断，则需要先设置一个内存读屏障，如果在写一个外设时发生中断，则需要在之后设置一个内存写屏障。

[1] BCM2835 上具有一个 128KB 的 L2 cache，主要用于 GPU。访问内存时是经过还是绕过 L2 cache 由总线地址的高两位决定。

[2] 一般来说，在执行两次读操作时，处理器假定数据是按序返回的。所以先从 X 位置处读数据再从 Y 位置处读取数据时，应先返回 X 位置的数据。返回数据的顺序发生错乱将导致错误的结果。例如：

a_status = *pointer_to_peripheral_a;
b_status = *pointer_to_peripheral_b;


没有采取预防措施时，a_status 和 b_status 的数值可能会发生交换。

理论上这可能会导致错误，但实际上这种情况很难发生，因为 AXI 系统可以确保数据始终被按序地送到目的地。因此：

*pointer_to_peripheral_a = value_a;
*pointer_to_peripheral_b = value_b;

一直是正确的。唯一可能出现错误的时候是不同的外设被连接到了相同的外部设备。


/////////////////////////////////////////
内存屏障
/////////////////////////////////////////
    内存屏障，也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。
    大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。
    语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。


/////////////////////////////////////////
VideoCore
/////////////////////////////////////////
    VideoCore 是一个由Alphamosaic Ltd开发并且现在被Broadcom拥有的低功耗移动多媒体指令集架构。二维的DSP架构使其在软件中可以灵活且高效地编解码多媒体数据的同时保持低功耗。该IP核目前仅在Broadcom的SoC中被使用。

